An event is:
An immutable, self-contained fact that was true at a specific time, independent of how we interpret it today.
That means:
â€¢	No derived state
â€¢	No projection assumptions
â€¢	No â€œbefore/afterâ€
Only what happened.

Now Letâ€™s Design the Event Envelope

This is the minimum viable, production-safe event record.

1ï¸âƒ£ event_id (UUID)
Globally unique
Idempotency anchor
Never reused
âœ… You got this right.

2ï¸âƒ£ aggregate_id
The entity this event belongs to (e.g. order_id)
Allows grouping events
Enables replay per entity
Without this, replay is painful.

3ï¸âƒ£ aggregate_type
Example:
ORDER
PAYMENT
Why not infer it?
Explicit > implicit
Enables generic tooling

4ï¸âƒ£ event_type
Example:
OrderCreated
PaymentRequested
This tells us what fact occurred.

5ï¸âƒ£ event_version
This is what you meant by â€œbefore/after logic changeâ€.
Example:
1
2
Why:
Schema evolution
Backward compatibility
Deterministic replay across versions

6ï¸âƒ£ event_time
When the event occurred (business time).
Not:
when we processed it
not when projection updated
This matters for audits.

7ï¸âƒ£ emitted_by
This maps to your â€œwhich service triggered itâ€.
Example:
order-service
payment-service
Good instinct â€” keep it.

8ï¸âƒ£ payload (JSON / JSONB)
This is the actual fact.
Example:
{
  "orderId": "123",
  "items": [...],
  "totalAmount": 499.00
}
This is the single source of truth for the event.
No before/after.
No derived fields.

9ï¸âƒ£ metadata (optional but powerful)
Examples:
request_id
trace_id
correlation_id
Used for:
debugging
observability
cross-service tracing
Not used for business logic.
What We Intentionally Do NOT Store
ğŸš« Before state
ğŸš« After state
ğŸš« Projection-specific fields
ğŸš« Calculated values that can be recomputed

Because:
History must be future-proof, not present-friendly.
