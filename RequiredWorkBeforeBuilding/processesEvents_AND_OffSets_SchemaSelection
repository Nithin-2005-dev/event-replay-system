1Ô∏è‚É£ consumer_name
Why it must exist
processed state is scoped per consumer
same event can be processed by multiple consumers independently
Without this:
consumers interfere
rebuilds become impossible
offsets lose meaning
So this is mandatory.

2Ô∏è‚É£ event_id
Why this is the key
idempotency is per event fact, not per aggregate
duplicate delivery is handled here
crash recovery depends on this
This is the identity of what we‚Äôre protecting.
Mandatory.

3Ô∏è‚É£ state
Why this is required
This encodes the event‚Äôs lifecycle for the consumer:
implicit NOT_PROCESSED ‚Üí no row
WAITING ‚Üí deferred due to missing prerequisites
PROCESSED ‚Üí applied, must never be applied again
Without state:
retries can‚Äôt be controlled
deferred logic collapses
crashes cause re-application
Mandatory.

Important clarification (this is subtle)
NOT_PROCESSED is NOT stored
That‚Äôs intentional.
absence of (consumer_name, event_id) = NOT_PROCESSED
storage only tracks decisions, not default state
This keeps the table small and meaningful.
A unique constraint on (consumer_name, event_id) guarantees:

1Ô∏è‚É£ Idempotency at the database level
Even if:
the consumer crashes
the same event is read twice
retry logic fires
concurrent threads race
üëâ the database physically prevents duplicate processing records.
This is critical because:
application-level checks are not enough
race conditions happen inside transactions

2Ô∏è‚É£ Safe state transitions
Since the row is unique:
NOT_PROCESSED ‚Üí WAITING ‚Üí PROCESSED
state changes happen via UPDATE, not INSERT
there is exactly one lifecycle per event per consumer
Without uniqueness:
you could have two rows:
one WAITING
one PROCESSED
üëâ impossible to reason about correctness

3Ô∏è‚É£ Crash recovery correctness
After restart:
consumer reads event again
queries processed_events
gets exactly one answer
No guessing. No ambiguity.

Why a separate offset table is the only sane option
1Ô∏è‚É£ Offset is a consumer property, not an event property
An offset answers exactly one question:
‚ÄúUp to which event has THIS consumer safely applied its logic?‚Äù
That is:
one value
per consumer
monotonic
global for that consumer
processed_events answers a different question:
‚ÄúWhat happened to THIS specific event?‚Äù
Mixing these two creates conceptual corruption.

2Ô∏è‚É£ Redundancy is not harmless here
If you stored offset per row in processed_events:
you‚Äôd repeat the same offset value thousands of times
updates would be expensive
consistency becomes hard to reason about
Worse:
two rows could disagree on ‚Äúcurrent offset‚Äù
crash recovery logic becomes ambiguous
Offsets must have exactly one authoritative value.

3Ô∏è‚É£ Offset advancement semantics demand isolation
Offsets move only when:
an event is applied
processed state is persisted
transaction commits
That movement must be:
atomic
singular
deterministic
This is impossible to guarantee if offset is scattered across rows.

CREATE TYPE processing_state AS ENUM (
    'PROCESSED',
    'WAITING'
);

CREATE TABLE processed_events (
    consumer_name TEXT NOT NULL,
    event_sequence BIGINT NOT NULL,

    state processing_state NOT NULL,

    PRIMARY KEY (consumer_name, event_sequence),

    FOREIGN KEY (event_sequence)
        REFERENCES event_log(event_sequence)
);
CREATE TABLE consumer_offsets (
    consumer_name TEXT PRIMARY KEY,
    last_committed_event_sequence BIGINT NOT NULL
);
