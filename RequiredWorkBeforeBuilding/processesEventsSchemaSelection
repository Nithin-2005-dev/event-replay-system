1ï¸âƒ£ consumer_name

Why it must exist

processed state is scoped per consumer

same event can be processed by multiple consumers independently

Without this:

consumers interfere

rebuilds become impossible

offsets lose meaning

So this is mandatory.

2ï¸âƒ£ event_id

Why this is the key

idempotency is per event fact, not per aggregate

duplicate delivery is handled here

crash recovery depends on this

This is the identity of what weâ€™re protecting.

Mandatory.

3ï¸âƒ£ state

Why this is required
This encodes the eventâ€™s lifecycle for the consumer:

implicit NOT_PROCESSED â†’ no row

WAITING â†’ deferred due to missing prerequisites

PROCESSED â†’ applied, must never be applied again

Without state:

retries canâ€™t be controlled

deferred logic collapses

crashes cause re-application

Mandatory.

Important clarification (this is subtle)

NOT_PROCESSED is NOT stored

Thatâ€™s intentional.

absence of (consumer_name, event_id) = NOT_PROCESSED

storage only tracks decisions, not default state

This keeps the table small and meaningful.

A unique constraint on (consumer_name, event_id) guarantees:

1ï¸âƒ£ Idempotency at the database level

Even if:

the consumer crashes

the same event is read twice

retry logic fires

concurrent threads race

ğŸ‘‰ the database physically prevents duplicate processing records.

This is critical because:

application-level checks are not enough

race conditions happen inside transactions

2ï¸âƒ£ Safe state transitions

Since the row is unique:

NOT_PROCESSED â†’ WAITING â†’ PROCESSED

state changes happen via UPDATE, not INSERT

there is exactly one lifecycle per event per consumer

Without uniqueness:

you could have two rows:

one WAITING

one PROCESSED
ğŸ‘‰ impossible to reason about correctness

3ï¸âƒ£ Crash recovery correctness

After restart:

consumer reads event again

queries processed_events

gets exactly one answer

No guessing. No ambiguity.

